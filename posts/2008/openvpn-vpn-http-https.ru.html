<html><body><div dir="ltr" style="text-align: left;">В некоторых сетях единственным доступным сервисом является веб через прокси-сервер. Многие сервисы (ssh, почта, некоторые IM) не могут работать через прокси, но существуют способы пробросить vpn на какой-либо удаленных хост.<br><br>Итак, после проведения некоторого исследования, выбор пал на openvpn. И вот как я его настраивал:<br><br><a name="more"></a><br><br><h2>1: установка OpenVPN</h2><br>У меня было две машины: мой ноутбук (note) и домашний сервер vpn.mydomain.ru (который выполняет у меня функции интернет-шлюза, кешрующего прокси, тестового веб-сервера, файлохранилища, и многого чего другого).<br><br>Установка и на том и на другом прошла очень легко (строго говоря, он у меня уже был установлен "на всякий случай"):<br><pre class="brush: bash">emerge -av1 openvpn<br></pre>Отмечу полезный USE-флаг: examples. Он включает установку примеров конфигурационных файлов, которыми можно воспользоваться как основой для написания своих.<br><br><h2>2: конфигурация сервера</h2><br>Первое что нужно сделать, это сгенерировать все необходимые ключи, это можно сделать с помощью скриптов, входящих в комплект openvpn:<br><br><pre class="brush: bash">cd /usr/share/openvpn/easy-rsa/<br><br># инициализация<br>. ./vars<br>./clean-all<br><br># эта команда создает Certificate Authority, выполняется интерактивно (т.е. вам нужно будет<br>#ответить на несколько вопросов). Можно оставить все по умолчанию, изменив лишь данные о<br>#географическом положении.<br># Единственный вопрос, на который следует обратить внимание - Common Name. Не так важно, что вы<br>#туда введте, но он должен быть установлен.<br>./build-ca<br><br># генерация пары ключей для сервера<br>./build-key-server server<br><br># генерация пары ключей для клиента<br>./build-key note<br><br># генерация Diffie Hellman:<br>./build-dh<br></pre><br>После этого в поддиректории keys появятся все необходимые ключи.<br>Переместите их в какое-нибудь надежное и защищеное место.<br>Скопируйте файлы ca.crt и note.* на клиент.<br><br>Строго говоря, можно было сгенерировать пару ключей на клиенте и передать на сервер публичный ключ для подписи. Но поскольку у меня был защищеный канал (ssh) между клиентом и сервером, я сгенерировал все в одном месте.<br><br>Далее нужно написать конфигурационный файл для openvpn. У меня получилось так:<br><pre class="brush: bash"># биндимся к порту 443, т.к. это единственный порт, на который разрешено делать CONNECT на том прокси-сервере<br>#port 1194<br>port 443<br><br># TCP or UDP server?<br>proto tcp<br>;proto udp<br><br>dev tun<br><br># пути к файлам сертификатов<br>ca /etc/openvpn/keys/ca.crt<br>cert /etc/openvpn/keys/server.crt<br>key /etc/openvpn/keys/server.key  # This file should be kept secret<br>dh /etc/openvpn/keys/dh1024.pem<br><br># тут важно выбрать такую подсеть, которая не пересекалась бы ни с одной другой используемой вами<br>server 192.168.120.0 255.255.255.0<br><br>ifconfig-pool-persist ipp.txt<br><br># так можно указывать клиенту, какие сети нужно маршритизировать через этот vpn<br>;push "route 192.168.1.0 255.255.255.0"<br><br># а так можно указать, что этот vpn следует сделать шлюзом по умолчанию (что нам и нужно)<br>push "redirect-gateway"<br><br><br><br># Разрешаем клентам взаимодействовать друг с другом, по умолчанию отключено<br>client-to-client<br><br># The keepalive directive causes ping-like<br># messages to be sent back and forth over<br># the link so that each side knows when<br># the other side has gone down.<br># Ping every 10 seconds, assume that remote<br># peer is down if no ping received during<br># a 120 second time period.<br>keepalive 10 120<br><br># включаем компрессию<br>comp-lzo<br><br># так можно указать максимально количество клиентов<br>;max-clients 100<br><br># так можно заставить openvpn сбросить права<br>;user nobody<br>;group nobody<br><br># The persist options will try to avoid<br># accessing certain resources on restart<br># that may no longer be accessible because<br># of the privilege downgrade.<br>persist-key<br>persist-tun<br><br># лог-фай<br>status openvpn-status.log<br></pre><br>Запуск сервера происходит командой openvpn /etc/openvpn/server.conf.<br>Перед запуском надо подгрузить модуль tun.<br><br><h2>3: Конфигурация клиента</h2><br>Вот конфигурационный файл:<br><pre class="brush: bash">client<br><br>dev tun<br><br># указываем протокол и прокси<br>proto tcp<br>http-proxy proxy 3128<br>;http-proxy-retry # retry on connection failures<br><br># указываем адрес и порт удаленного сервера<br>remote vpn.mydomain.ru 443<br><br>resolv-retry infinite<br>nobind<br><br># Downgrade privileges after initialization (non-Windows only)<br>;user nobody<br>;group nobody<br><br>persist-key<br>persist-tun<br><br># пути к сертификатам и ключам<br>ca /etc/openvpn/keys/ca.crt<br>cert /etc/openvpn/keys/note.crt<br>key /etc/openvpn/keys/note.key<br><br># разрешаем компрессию<br>comp-lzo<br></pre><br>После подгрузки модуля tun и запуска клиента, можно убедиться что интерфейс поднимается, и сервер пингуется.<br>Внимание: после поднятия vpn, openvpn перепишет шлюз по умолчнию, так что нужно заранее добавить статические маршруты (если таковых нету) к прокси-серверу и местной локальным ресурсам.<br><br>Однако после поднятия vpn, внешние ресурсы все еще не будут работать. А все потому что нужно выполнить шаг<br><h2>4: настройка NAT</h2><br>Во-первых, разрешаем серверу маршрутизировать пакеты. Для этого пишем в /etc/sysctl следующее:<br><pre class="brush: bash">net.ipv4.ip_forward = 1<br>net.ipv4.ip_dynaddr = 1<br></pre>После чего выполняем sysctl -a.<br><br>Далее нужно средствами iptables настроить правила маскарадинга. Для этого удобно написать sh-скриптик, который в дальнейшем будет удобно пополнять и редактировать. У меня он имеет примерно такой вид (сокращено):<br><pre class="brush: bash">#!/bin/sh<br><br># маски используемых сетей<br>IP_LAN="192.168.1.1/24" # моя домашняя сеть<br>IP_PROVIDER="10.0.0.1/8" # локальная сеть провайдера<br><br># интерфейсы<br>IF_EXT="eth1" # сюда подключен Ethernet от провайдера<br>IF_LAN="eth0" # сюда подключена локальная сеть<br>IF_INET="ppp0" # сюда "подключен" интернет<br>IF_VPN="tun0" # это интерфейс нашего vpn<br><br>IPT="iptables"<br><br># cleaning:<br>$IPT --flush<br>$IPT -t nat --flush<br>$IPT -t mangle --flush<br>$IPT -X<br><br># тут по желанию и степени паранои<br>$IPT -P INPUT ACCEPT<br>$IPT -P OUTPUT ACCEPT<br>$IPT -P FORWARD ACCEPT<br><br># allow loopback<br>$IPT -A INPUT -i lo -j ACCEPT<br>$IPT -A OUTPUT -o lo -j ACCEPT<br><br>###<br># local host:<br><br># allow outgoing connections:<br>$IPT -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT<br>$IPT -A OUTPUT -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT<br><br># разрешаем подключения к vpn<br>$IPT -A INPUT -p tcp --dport 443 -j ACCEPT<br><br># разрешаем NAT из локальной сети и VPN:<br>$IPT -t nat -A POSTROUTING -o $IF_EXT -j MASQUERADE<br>$IPT -t nat -A POSTROUTING -o $IF_INET -j MASQUERADE<br><br>$IPT -A FORWARD -i $IF_LAN -o $IF_EXT -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT<br>$IPT -A FORWARD -i $IF_EXT -o $IF_LAN -m state --state ESTABLISHED,RELATED -j ACCEPT<br>$IPT -A FORWARD -i $IF_LAN -o $IF_INET -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT<br>$IPT -A FORWARD -i $IF_INET -o $IF_LAN -m state --state ESTABLISHED,RELATED -j ACCEPT<br><br>$IPT -A FORWARD -i $IF_VPN -o $IF_EXT -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT<br>$IPT -A FORWARD -i $IF_EXT -o $IF_VPN -m state --state ESTABLISHED,RELATED -j ACCEPT<br>$IPT -A FORWARD -i $IF_VPN -o $IF_INET -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT<br>$IPT -A FORWARD -i $IF_INET -o $IF_VPN -m state --state ESTABLISHED,RELATED -j ACCEPT<br></pre><br>После выполнения скрипта достаточно сделать <code>/etc/init.d/iptables save</code> и добавить iptables в runlevel: <code>rc-update add iptables default</code></div></body></html>
